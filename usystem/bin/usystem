#!/usr/bin/env bash
#shellcheck disable=SC2155,SC3040,SC3041
# SC2155: Declare and assign separately to avoid masking return values
#===============================================================================
# IMPLEMENTATION
#===============================================================================
#% ${CLI_NAME}: Synology User System
#%    version:        ${CLI_VERSION}
#%    author:         G.J.R. Timmer (https://www.timmertech.io)
#%    license:        MIT
#%
#% ENVIRONMENT
#%    name:           ${CLI_NAME}
#%    bind:           ${USYS_BIND_DIR}
#%    volume:         ${USYS_VOLUME}
#%    target:         ${USYS_TARGET}
#%    root:           ${USYS_ROOT}
#%    backup:         ${USYS_BACKUP_DIR}
#%    config          ${USYS_CONFIG_DIR}
#%    config file:    ${USYS_CONFIG}
#%    log:            ${USYS_LOG_DIR}
#%    tmp:            ${USYS_TMP_DIR}
#%
#% REPOSITORY
#%    url:            ${USYS_REPO_URL}
#%
#===============================================================================
# IMPLEMENTATION_END
#===============================================================================
# USAGE
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} [OPTIONS] [COMMAND] [CMD_OPTIONS...]
#%
#% DESCRIPTION
#%    Synology User System Control
#%    This script allows you to control the Synology User System
#%
#% COMMANDS
#%    backup            Backup user system
#%    clean             Clean user system
#%    install           Install Synology user system
#%    link              Link user system resources to DSM
#%    repair            Repair user system, used after DSM update/upgrade
#%    upgrade           Upgrade user system to latest version
#%    help              Show usage information
#%    version           Show version and implementation information
#%
#% HELP
#%    Providing -h, --help or help as parameter to a command will show the usage
#%    information of a particular command.
#%
#% EXAMPLES
#%    ${CLI_NAME} repair
#%    ${CLI_NAME} link
#%    ${CLI_NAME} install
#%
#===============================================================================
# USAGE_END
#===============================================================================
# INSTALL
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} install [OPTIONS...]
#%
#% DESCRIPTION
#%    This will install the Synology User System
#%
#% OPTIONS
#%    -f, --force           Forced install, will override any safety measure.
#%                          A forced install will only create the config if not
#%                          present. (default false) [FORCE]
#%        --force-config    Override config with default config, without this option
#%                          a forced install will keep a previous config intact.
#%                          (default false) [FORCE_CONFIG]
#%        --cli-name        Will set the name of the cli command, this will propagate to the target directory,
#%                          root directory and config file name. This will allow multiple installations.
#%                          (default usystem) [CLI_NAME]
#%    -b, --bind-dir        Directory in root where the usystem will be bound (default /usys) [USYS_BIND_DIR]
#%    -v, --volume          Set volume to install to (default /volume1) [USYS_VOLUME]
#%    -t, --target-dir      Set target installation directory (default USYS_VOLUME/@usystem) [USYS_TARGET]
#%    -r, --root-dir        Set root directory (default USYS_TARGET/usystem) [USYS_ROOT]
#%        --backup-dir      Set backup directory (default USYS_TARGET/backup) [USYS_BACKUP_DIR]
#%        --config-dir      Set config directory (default USYS_ROOT/etc) [USYS_CONFIG_DIR]
#%        --log-dir         Set log direcotory (default USYS_ROOT/log) [USYS_LOG_DIR]
#%        --local FILE      Install from locally download file.
#%                          If not provided usystem will be downloaded from repository.
#%                          This option will not be presisted to usystem.conf after install.
#%                          (default USYS_ROOT/usystem.tgz) [USYS_REPO_ARCHIVE]
#%    -h, --help            Show this help
#%
#% HELP
#%    Options can be provided by environment variables defined within brackets [].
#%
#===============================================================================
# INSTALL_END
#===============================================================================
# REPAIR
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} repair [OPTIONS...]
#%
#% DESCRIPTION
#%    Repair user system, used after DSM update/upgrade
#%    The repair will install the required resources for auto-start and
#%    perform the link of resources.
#%
#% OPTIONS
#%        --force-config    Override config with default config (default false) [FORCE_CONFIG]
#%    -h, --help            Show this help
#%
#===============================================================================
# REPAIR_END
#===============================================================================
# LINK
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} link
#%
#% DESCRIPTION
#%    Link user system resources to DSM
#%
#===============================================================================
# LINK_END
#===============================================================================


#===============================================================================
# SHELL CONFIG
#===============================================================================
set -T          # inherit DEBUG and RETURN trap for functions
set -C          # prevent file overwrite by > &> <>
set -E          # inherit -e
set -e          # exit immediately on errors
set -u          # exit on not assigned variables
set -o pipefail # exit on pipe failure

# Define script finish function
trap 'finish' EXIT


#===============================================================================
# GLOBAL VARS
#===============================================================================
# CLI_NAME
# Name of the CLI command. This can be overriden during install.
# This will allow multiple installations next to each other.
# When set during install, the name will be written as readonly variable to the
# install variable.
declare     CLI_NAME="${CLI_NAME:-usystem}"

# CLI Version
declare -r  CLI_VERSION=1.0.0;
declare -r  CLI_DIR="$( cd "$(dirname "$0")" && pwd )";

# Logging
#
# Please note that the log level NONE does not mean 'No Logging'
# NONE is used for output without a log level
declare -rA LOG_LEVELS=([NONE]=0 [DEBUG]=1 [INFO]=2 [WARN]=3 [ERROR]=4);
declare -r  LOG_PFX='%-32s '
declare     LOG_LEVEL="${LOG_LEVEL:-INFO}";

# User System VARS
declare     USYS_BIND_DIR="${USYS_BIND_DIR:-/usys}"
declare     USYS_VOLUME="${USYS_VOLUME:-/volume1}";
declare     USYS_TARGET="${USYS_TARGET:-"${USYS_VOLUME}/@${CLI_NAME}"}";
declare     USYS_ROOT="${USYS_ROOT:-"${USYS_TARGET}/${CLI_NAME}"}";
declare     USYS_BACKUP_DIR="${USYS_BACKUP_DIR:-${USYS_TARGET}/backup}";
declare     USYS_CONFIG_DIR="${USYS_CONFIG_DIR:-${USYS_ROOT}/etc}";
declare     USYS_LOG_DIR="${USYS_LOG_DIR:-${USYS_ROOT}/log}";
declare -r  USYS_TMP_DIR="${USYS_TMP_DIR:-${USYS_ROOT}/tmp}";
declare -r  USYS_CONFIG="${USYS_CONFIG:-${USYS_CONFIG_DIR}/${CLI_NAME}.conf}"

# User System Repository
declare -r  USYS_REPO_URL="${USYS_REPO_URL:-https://github.com/TimmerTech/synology-usystem}";
declare -r  USYS_REPO_ARCHIVE="${USYS_REPO_ARCHIVE:-${USYS_TARGET}/${CLI_NAME}.tgz}";

# CLI Exec Date/Time
declare -r  CLI_EXEC_DT="$(date +'%Y%m%d-%H%M%S')";

# Install Variables
declare     FORCE=false
declare     FORCE_CONFIG=false

# We will now load the config from the installed location the usystem.conf.
# The configuration will be loaded relative to this script.
# For saftey reasons the variables set during the install phase
# are written to the config as readonly variables.
# This is to ensure that we do not make mistakes. Because during initial install
# the configuration does not exists therefor the variables in the configuration
# marked as readonly are not an issue. This does also provide a secondary benefit.
# When a re-install is preformed, the user can reinstall over the current install
# because the configuration will lock the install variables.
if [[ -t 1 ]]; then
    if [ -f "${CLI_DIR}/../etc/${CLI_NAME}.conf" ]; then
        # shellcheck source=../etc/default/usystem.conf
        source "${CLI_DIR}/../etc/${CLI_NAME}.conf"
    fi
fi


#===============================================================================
# FUNCTIONS
#===============================================================================
function scriptinfo_part() {
    local -r PART="${1}"
    local -r FILTER="${2}"

    sed -n "/${PART}/,/${PART}_END/p" "${0}" | grep -e "${FILTER}" | sed -e "s/${FILTER}//g"
}

function scriptinfo_replace_var() {
    local -r VARNAME="${1}"

    sed -e "s|\${${VARNAME}}|${!VARNAME}|g"
}

# scriptinfo
#
# Parameters
#   (1) EXIT Code
#   (2) Command to display info for, defaults to 'help'
#   (3) short/full; display short or full info, defaults to 'full'
function scriptinfo() {
    # Parameters
    local -r EXIT="${1:-0}"
    local -r CMD="${2:-help}"
    local -r DISPLAY="${3:-full}"

    # Filter
    local FILTER="^#[%+]";

    # Configure Display by altering FILTER
    case "${DISPLAY,,}" in
        short ) FILTER="^#+"    ;;
        full  ) FILTER="^#[%+]" ;;
    esac

    case "${CMD,,}" in
        help | usage)
            scriptinfo_part USAGE "${FILTER}" | scriptinfo_replace_var CLI_NAME
        ;;

        version | implementation)
                scriptinfo_part IMPLEMENTATION "${FILTER}" |
                scriptinfo_replace_var CLI_NAME |
                scriptinfo_replace_var CLI_VERSION |
                scriptinfo_replace_var USYS_VOLUME |
                scriptinfo_replace_var USYS_TARGET |
                scriptinfo_replace_var USYS_ROOT |
                scriptinfo_replace_var USYS_BACKUP_DIR |
                scriptinfo_replace_var USYS_CONFIG_DIR |
                scriptinfo_replace_var USYS_LOG_DIR |
                scriptinfo_replace_var USYS_TMP_DIR |
                scriptinfo_replace_var USYS_REPO_URL
        ;;

        *)
            scriptinfo_part "${CMD^^}" "${FILTER}" | scriptinfo_replace_var CLI_NAME
        ;;
    esac

    exit "${EXIT:-0}"
}

function is_root() {
    local -r CMD="${1}"

    if [[ $(/usr/bin/id -u) -ne 0 ]]; then
        printf "'${CLI_NAME} %s' must be run as root\n" "${CMD}"
        exit 1
    fi
}

function exists() {
    local -r PATH="${1}"

    if [ -e "${PATH}" ]; then
        return 0
    else
        return 1
    fi
}

## Check if enabled
# $1 parameter to Check
#
# usage: if is_enabled "${VAR}"; then
function is_enabled() {
    local -r BOOL="${1}"

    if [ "${BOOL}" = 1 ] || [ "${BOOL}" = true ] || [ "${BOOL,,}" = "true" ] || [ "${BOOL,,}" = "enable" ] || [ "${BOOL,,}" = "enabled" ] || [ "${BOOL,,}" = "on" ]; then
        return 0
    fi

    return 1
}

function log() {
    local -r LVL="${1}"
    local -r MSG="${2}"

    # Check if log level exists
    [[ ${LOG_LEVELS[${LVL}]} ]] || return 1

    # If log level is NONE; we output the message raw
    if (( ${LOG_LEVELS[${LVL}]} == 0 )) && [ -n "${MSG}" ]; then
        echo "${MSG}"
        return 0
    fi

    # Check is current log level is allowed
    if (( ${LOG_LEVELS[${LVL}]} <= ${LOG_LEVELS[${LOG_LEVEL}]} )); then
        if [ -n "${MSG}" ]; then
            printf '%-5s: %s\n' "${LVL}" "${MSG}"
        fi
    fi
}

function fecho() {
    local -r MSG="${1}"

    # shellcheck disable=SC2059
    printf "${LOG_PFX}" "${MSG}"
}

function fresult() {
    local -r RES="${1}"
    local -r LVL="${2:-NONE}"
    local -r MSG="${3:-""}"

    printf '[%s]\n' "${RES}"
    log "${LVL}" "${MSG}"
}

# shellcheck disable=SC2120
function ok() {
    local -r LVL="${1:-NONE}"
    local -r MSG="${2:-""}"

    fresult OK "${LVL}" "${MSG}"
}

# shellcheck disable=SC2120
function fail() {
    local -r LVL="${1:-NONE}"
    local -r MSG="${2:-""}"

    fresult FAILED "${LVL}" "${MSG}"
}

function umount() {
    # unmount /usys/tmp
    if grep ' /usys/tmp ' /proc/mounts > /dev/null 2>&1; then
        fecho "umounting usystem:tmp ..."
        if umount /usys/tmp; then
            ok
        else
            fail ERROR "Failed to umount, manual install required" && exit 1
        fi
    fi

    # umount /usys
    if grep ' /usys ' /proc/mounts > /dev/null 2>&1; then
        fecho "unmounting usystem ..."
        if umount /usys; then
            ok
        else
            fail ERROR "Failed to umount, manual install required" && exit 1
        fi
    fi
}

# Create directories, not every directory of usystem is stored in the
# repository. Therefor create all required directories.
function create_directories() {
    # Directories
    local -ra DIRECTORIES=(
        etc/certs
        etc/nginx/conf.d
        etc/nginx/sites.enabled
        log
        reports
        sbin
    )

    for DIR in "${DIRECTORIES[@]}"; do
        if [ ! -d "${USYS_ROOT}/${DIR}" ]; then
            mkdir -p "${USYS_ROOT}/${DIR}" || return 1
        fi
    done

    return 0
}

function fix_permissions() {
    local -r LOG="${1}"

    # set permissions on /usys
    chmod -v 755 /usys >> "${LOG}" 2>&1 || return 1
    chown -v root:root /usys >> "${LOG}" 2>&1 || return 1

    local -A PERMISSIONS
    PERMISSIONS[${USYS_ROOT}/bin]="775 root:administrators"
    PERMISSIONS[${USYS_ROOT}/etc]="775 root:administrators"
    PERMISSIONS[${USYS_ROOT}/log]="775 root:administrators"
    PERMISSIONS[${USYS_ROOT}/sbin]="755 root:administrators"

    for P in "${!PERMISSIONS[@]}"; do
        # shellcheck disable=SC2206
        PERM=(${PERMISSIONS[$P]})
        CHMOD=${PERM[0]}
        CHOWN=${PERM[1]}

        chmod -Rv "${CHMOD}" "${P}" >> "${LOG}" 2>&1 || return 1
        chown -Rv "${CHOWN}" "${P}" >> "${LOG}" 2>&1 || return 1
    done

    return 0
}

function install_vars() {

    # Make sure we start with a clean environment
    rm -f "${USYS_TARGET}/VARS.env"

    cat > "${USYS_TARGET}/VARS.env" <<EOF
declare -r CLI_NAME=${CLI_NAME}
declare -r USYS_BIND_DIR=${USYS_BIND_DIR}
declare -r USYS_VOLUME=${USYS_VOLUME}
declare -r USYS_TARGET=${USYS_TARGET}
declare -r USYS_ROOT=${USYS_ROOT}
declare -r USYS_BACKUP_DIR=${USYS_BACKUP_DIR}
declare -r USYS_CONFIG_DIR=${USYS_CONFIG_DIR}
declare -r USYS_LOG_DIR=${USYS_LOG_DIR}
declare -r USYS_TMP_DIR=${USYS_TMP_DIR}
EOF

    # Install Variables in files
    # shellcheck disable=SC2016
    sed -i "/+++INSTALL_VARS+++/ {
        r ${USYS_TARGET}/VARS.env
        d
    }" "${USYS_CONFIG_DIR}/default/usystem.conf"
    # shellcheck disable=SC2016
    sed -i "/+++INSTALL_VARS+++/ {
        r ${USYS_TARGET}/VARS.env
        d
    }" "${USYS_CONFIG_DIR}/default/usystem.conf"
    # shellcheck disable=SC2016
    sed -i "/+++INSTALL_VARS+++/ {
        r ${USYS_TARGET}/VARS.env
        d
    }" "${USYS_CONFIG_DIR}/default/usystem.conf"

    # Cleanup temporary install files
    rm -f "${USYS_TARGET}/VARS.env"
}

function download() {
    local -r LOG="${USYS_TARGET}/${CLI_NAME}.download.${CLI_EXEC_DT}.log"

    # Set umask
    umask 022

    fecho "Downloading usystem ..."
    if wget -L "${USYS_REPO_URL}/archive/main.tar.gz" -O "${USYS_REPO_ARCHIVE}" -o "${LOG}" > /dev/null 2>&1; then
        ok
    else
        fail ERROR "Failed to download usystem; see log: ${LOG}"
    fi

    return 0
}

function install_archive() {
    local -r LOG="${1}"
    local -r FORCE="${2:-false}"
    local -r FORCE_CONFIG="${3:-false}"

    # Set umask
    umask 022

    # Remove USYS_TARGET/install before installing, this directory might be
    # present due to install failure
    if [ -d "${USYS_TARGET}/install" ]; then
        rm -rf "${USYS_TARGET}/install"
    fi

    # Create temporary install directory
    mkdir -p "${USYS_TARGET}/install"

    fecho "Installing ..."
    # Extract archive to USYS_TARGET/install, we are installing to this temporary directory
    # because the user might have choosen to override the default of USYS_ROOT
    # therefor we must create the USYS_ROOT and move the entire usystem here.
    if tar -xvf "${USYS_REPO_ARCHIVE}" --strip-components=1 -C "${USYS_TARGET}/install" > "${LOG}" 2>&1; then

        # Create USYS_ROOT
        if [ ! -d "${USYS_ROOT}" ]; then
            mkdir -p "${USYS_ROOT}"
        fi

        # Now copy the usystem to the its final destination
        if ! cp -rav "${USYS_TARGET}/install/${CLI_NAME}"/* "${USYS_ROOT}" >> "${LOG}" 2>&1; then
            fail ERROR "Failed to move usystem; see log: ${LOG}" && exit 1
        fi

        # Copy LICENSE to USYS_TARGET
        if ! cp -rav "${USYS_TARGET}/install/LICENSE" "${USYS_TARGET}/LICENSE" >> "${LOG}" 2>&1; then
            fail ERROR "Failed to move LICENSE; see log: ${LOG}" && exit 1
        fi

        # Remove install folder, to make sure we cleanup after ourselfs
        rm -rf "${USYS_TARGET}/install" >> "${LOG}" 2>&1

        # Install OK
        ok
    else
        fail ERROR "failed to install; see log: ${LOG}"
    fi
}

# install_config
#
# Because we are calling this from the 'install' and 'repair' command
# we want to be able to show the correct message to the user
# therefor this function accepts a MSG as a parameter for this usecase
function install_config() {
    local -r FORCE_CONFIG="${1}"
    local -r MSG="${2}"

    # shellcheck disable=SC1009,SC1072,SC1073
    if [ ! -f "${USYS_CONFIG}" ] || is_enabled "${FORCE_CONFIG}"; then
        fecho "${MSG} config ..."
        if cp "${USYS_CONFIG_DIR}/default/usystem.conf" "${USYS_CONFIG}"; then
            ok
        else
            fail ERROR "Failed to install config"
        fi
    fi
}

# install_rc
#
# Because we are calling this from the 'install' and 'repair' command
# we want to be able to show the correct message to the user
# therefor this function accepts a MSG as a parameter for this usecase
function install_rc() {
    local -r MSG="${1}"

    fecho "${MSG} rc.usystem ..."
    if cp "${USYS_CONFIG_DIR}/default/rc.${CLI_NAME}" /etc; then
        ok
    else
        fail ERROR "Failed to install rc.${CLI_NAME}" && exit 1
    fi

    fecho "${MSG} rc.local ..."
    if cp "${USYS_CONFIG_DIR}/default/rc.local" /etc; then
        ok
    else
        fail ERROR "Failed to install rc.local" && exit 1
    fi
}


#===============================================================================
# COMMANDS
#===============================================================================
function install() {
    # Print header because we also provide online install
    printf '%s\n' "Synology User System"
    printf '%s\n\n' "Version: ${CLI_VERSION}"
    printf '%s\n\n' "For more information visit: https://www.timmertech.io"

    # Install Variables
    local FORCE="${FORCE:-false}"
    local FORCE_CONFIG="${FORCE_CONFIG:-false}"
    local LOCAL_INSTALL=false
    local LOG="${USYS_TARGET}/${CLI_NAME}.install.${CLI_EXEC_DT}.log"

    # Options array for calling the repair function after install
    local CMD_REPAIR_OPTS=("--install")

    # Parse Install Options
    while [ ${#} -gt 0 ]; do
        case $1 in
            -h | --help | help)
                scriptinfo 0 install
            ;;

            -f | --force)       FORCE=true;                 readonly FORCE;             shift 1 ;;
            -b,| --bind-dir)    USYS_BIND_DIR="${1}";       readonly USYS_BIND_DIR;     shift 2 ;;
            -v | --volume)      USYS_VOLUME="${1}";         readonly USYS_VOLUME;       shift 2 ;;
            -t | --target-dir)  USYS_TARGET="${1}";         readonly USYS_TARGET;       shift 2 ;;
            -r | --root-dir)    USYS_ROOT="${1}";           readonly USYS_ROOT;         shift 2 ;;

            --cli-name)         CLI_NAME="${1}"             readonly CLI_NAME;          shift 2 ;;
            --backup-dir)       USYS_BACKUP_DIR="${1}";     readonly USYS_BACKUP_DIR;   shift 2 ;;
            --config-dir)       USYS_CONFIG_DIR="${1}";     readonly USYS_CONFIG_DIR;   shift 2 ;;
            --log-dir)          USYS_LOG_DIR="${1}";        readonly USYS_LOG_DIR;      shift 2 ;;
            --force-config)
                FORCE_CONFIG=true;
                readonly FORCE_CONFIG;

                # Add option to repair command
                CMD_REPAIR_OPTS+=("--force-config")
                shift 1
            ;;
            --local)
                    LOCAL_INSTALL=true
                    USYS_REPO_ARCHIVE="${2}"
                    readonly USYS_REPO_ARCHIVE
                    shift 2
            ;;

            * )
                printf "unknown option: '%s'\n" "${1}"
                scriptinfo 1 install
            ;;
        esac
    done

    # Check if we are running as root
    is_root "${FUNCNAME[0]}"

    log NONE "${CLI_NAME} ${FUNCNAME[0]}"

    # Verify the volume path exists
    exists "${USYS_VOLUME}" || ( log ERROR "Volume: '${USYS_VOLUME}' does not exists" && exit 1 )

    # Create target directory on volume
    if [ ! -d "${USYS_TARGET}" ]; then
        mkdir -p "${USYS_TARGET}"
    fi

    # Create target directory on OS
    if [ ! -d /usys ]; then
        mkdir -p /usys
    fi

    # Verify that the root directory does not exist
    # If it exists, inform the user to use the 'upgrade' command
    # This check can be overridden with '--force'
    # shellcheck disable=SC1009,SC1072,SC1073
    if [ -d "${USYS_ROOT}" ] && ! is_enabled "${FORCE}"; then
        log ERROR "${USYS_ROOT} exist; please use '${CLI_NAME} upgrade'"
        exit 1
    fi

    # Because we have the option '--force' to perform a forced install
    # we must unmount the usystem if it exists.
    umount

    # Check if we are performing a local install
    # if not then remove possible present downloaded archive
    if ! is_enabled "${LOCAL_INSTALL}"; then
        rm -f "${USYS_REPO_ARCHIVE}"

        # set download log; because we might never be installed, write the
        # download log to USYS_TARGET
        download
    fi

    # Install archive, either downloaded or local
    install_archive "${LOG}" "${FORCE}" "${FORCE_CONFIG}"

    # Create directories
    fecho "Creating directories ..."
    if create_directories; then
        ok
    else
        fail ERROR: "Failed to create directories" && exit 1
    fi

    # Fix permissions of file/folders
    if ! fix_permissions "${LOG}"; then
        fail ERROR "Failed to repair permissions"
    fi

    # Install variables in files, this step is only done during install
    install_vars

    # Call repair user system, to finish the installation
    repair "${CMD_REPAIR_OPTS[@]}"
}

function repair() {
    local FORCE_CONFIG="${FORCE_CONFIG:-false}"
    local CONTEXT_MSG="Repairing"
    local CONTEXT_CFG="${CONTEXT_MSG}"

    log NONE "${CLI_NAME} ${FUNCNAME[0]}"

    # Parse Install Options
    while [ ${#} -gt 0 ]; do
        case $1 in
            -h | --help | help)
                scriptinfo 0 repair
            ;;

            # Hidden option, this option only exists for the call from the 'install' command
            # This option exists to correct the message output to the user
            --install)
                CONTEXT_MSG="Installing"
                shift 1
            ;;


            --force-config)
                FORCE_CONFIG=true; readonly FORCE_CONFIG;
                CONTEXT_CFG="Override"
                shift 1
            ;;

            * )
                printf "unknown option: '%s'\n" "${1}"
                scriptinfo 1 repair
            ;;
        esac
    done

    # Check if we are running as root
    is_root "${FUNCNAME[0]}"

    # Fix permissions
    fecho "Repairing permissions ..."
    if fix_permissions; then
        ok
    else
        fail ERROR "Failed to repair permissions" && exit 1
    fi

    # Install config
    install_config "${FORCE_CONFIG}" "${CONTEXT_CFG}"

    # Install run commands
    install_rc "${CONTEXT_MSG}"

    # Start usystem
    # We are going to start the user system from rc.local
    # The reason we are starting from rc.local is that rc.local after it starts
    # starts all user configured rc.d/* because we might be performing a forced
    # install and overwrite an existing installation
    /etc/rc.local

    # Repair completed, now link/re-link all usystem resources back to the OS
    # This will a user to only issue the repair command after a DSM upgrade to
    # completely restore everything
    #
    # Link user system resources to OS
    echo "\$@:" "$@"
    link "$@"
}

function link() {
    # Check if we are running as root
    is_root "${FUNCNAME[0]}"

    # Print command we are executing
    log NONE "${CLI_NAME} ${FUNCNAME[0]}"
}

#===============================================================================
# FINISH
#
# Script cleanup function
# ':' Returns TRUE to ensure empty function is allowed to be defined
#===============================================================================
function finish() {
    # Remove USYS_TARGET/install before installing, this directory might be
    # present due to install failure
    if [ -d "${USYS_TARGET}/install" ]; then
        rm -rf "${USYS_TARGET}/install"
    fi
}


#===============================================================================
# MAIN
#===============================================================================
function main() {
    if (( ${#} == 0 )); then
        scriptinfo 0 usage
    fi

    case ${1} in
        -h | --help | help )
            scriptinfo 0 usage
        ;;

        -v | --version | version )
            scriptinfo 0 version
        ;;

        -l | --log-level )
            LOG_LEVEL="${1^^}"
            shift 1
        ;;

        install )
            $1 "${@:2}";
        ;;

        * )
            echo "unknown command: $1";
            scriptinfo 1 usage
        ;;
    esac
}

main "$@";
