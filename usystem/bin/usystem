#!/usr/bin/env bash
#shellcheck disable=SC1083,SC2155,SC3040,SC3041
# SC2155: Declare and assign separately to avoid masking return values
#===============================================================================
# IMPLEMENTATION
#===============================================================================
#% ${CLI_NAME}: Synology User System
#%    version:        ${CLI_VERSION}
#%    author:         G.J.R. Timmer (https://www.timmertech.io)
#%    license:        MIT
#%
#% ENVIRONMENT
#%    name:           ${CLI_NAME}
#%    bind:           ${USYS_BIND_DIR}
#%    volume:         ${USYS_VOLUME}
#%    target:         ${USYS_TARGET}
#%    root:           ${USYS_ROOT}
#%    backup:         ${USYS_BACKUP_DIR}
#%    config          ${USYS_CONFIG_DIR}
#%    config file:    ${USYS_CONFIG}
#%    log:            ${USYS_LOG_DIR}
#%    tmp:            ${USYS_TMP_DIR}
#%
#% REPOSITORY
#%    url:            ${USYS_REPO_URL}
#%
#===============================================================================
# IMPLEMENTATION_END
#===============================================================================
# USAGE
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} [OPTIONS] [COMMAND] [CMD_OPTIONS...]
#%
#% DESCRIPTION
#%    Synology User System Control
#%    This script allows you to control the Synology User System
#%
#% COMMANDS
#%    backup            Backup user system
#%    generate          Generate files from templates
#%    install           Install Synology user system
#%    link              Link user system resources to DSM
#%    prune             Remove unused data
#%    repair            Repair user system, used after DSM update/upgrade
#%    upgrade           Upgrade user system to latest version
#%    help              Show usage information
#%    version           Show version and implementation information
#%
#% HELP
#%    Providing -h, --help or help as parameter to a command will show the usage
#%    information of a particular command.
#%
#% EXAMPLES
#%    ${CLI_NAME} repair
#%    ${CLI_NAME} link
#%    ${CLI_NAME} install
#%
#===============================================================================
# USAGE_END
#===============================================================================
# INSTALL
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} install [OPTIONS...]
#%
#% DESCRIPTION
#%    This will install the Synology User System
#%
#% OPTIONS
#%    -f, --force           Forced install, will override any safety measure.
#%                          A forced install will only create the config if not
#%                          present. (default false) [FORCE]
#%        --force-config    Override config with default config, without this
#%                          option a forced install will keep a previous
#%                          config intact. This will override the config with
#%                          the newly shipped config.
#%                          (default false) [FORCE_CONFIG]
#%        --force-profile   Override profile with default profile, without this
#%                          option a forced install will keep a previous profile
#%                          intact. This will override the profile with the newly
#%                          shipped profile. (default false) [FORCE_PROFILE]
#%        --cli-name        Will set the name of the cli command, this will
#%                          propagate to the target directory, root directory and
#%                          config file name. This will allow multiple
#%                          installations. (default usystem) [CLI_NAME]
#%    -b, --bind-dir        Directory in root where the usystem will be bound
#%                          (default /usys) [USYS_BIND_DIR]
#%    -v, --volume          Set volume to install to
#%                          (default /volume1) [USYS_VOLUME]
#%    -t, --target-dir      Set target installation directory
#%                          (default USYS_VOLUME/@usystem) [USYS_TARGET]
#%    -r, --root-dir        Set root directory
#%                          (default USYS_TARGET/usystem) [USYS_ROOT]
#%        --backup-dir      Set backup directory
#%                          (default USYS_TARGET/backup) [USYS_BACKUP_DIR]
#%        --config-dir      Set config directory
#%                          (default USYS_ROOT/etc) [USYS_CONFIG_DIR]
#%        --log-dir         Set log direcotory
#%                          (default USYS_ROOT/log) [USYS_LOG_DIR]
#%        --local FILE      Install from locally download file.
#%                          If not provided usystem will be downloaded from
#%                          repository. This option will not be presisted to
#%                          usystem.conf after install.
#%                          (default USYS_ROOT/usystem.tgz) [USYS_REPO_ARCHIVE]
#%    -h, --help            Show this help
#%
#% HELP
#%    Options can be provided by environment variables defined within brackets []
#%
#===============================================================================
# INSTALL_END
#===============================================================================
# REPAIR
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} repair [OPTIONS...]
#%
#% DESCRIPTION
#%    Repair user system, used after DSM update/upgrade
#%    The repair will install the required resources for auto-start and
#%    perform the link of resources.
#%
#% OPTIONS
#%        --force-config    Override config with default config
#%                          (default false) [FORCE_CONFIG]
#%        --force-profile   Override profile with default profile
#%                          (default false) [FORCE_PROFILE]
#%    -h, --help            Show this help
#%
#===============================================================================
# REPAIR_END
#===============================================================================
# LINK
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} link
#%
#% DESCRIPTION
#%    Link user system resources to DSM
#%
#===============================================================================
# LINK_END
#===============================================================================
# BACKUP
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} backup
#%
#% DESCRIPTION
#%    Backup user system. After a backup is succesfully created the backup clean
#%    will run to cleanup any backups which exceeds
#%    the number of backups to keep.
#%    BACKUP_KEEP_LAST can be provided in the ${CLI_NAME}.conf.
#%
#% OPTIONS
#%    -c, --clean               Cleanup backups after creation
#%    -f. --force               Do not prompt for confirmation
#%    -r, --backup-retain N     Retain this number of backups
#%                              (default 30) [BACKUP_RETAIN]
#%    -h, --help                Show this help
#%
#% BACKUP_KEEP_LAST
#%    Order of precendence, the higher the more important
#%    - Commandline argument
#%    - ${CLI_NAME}.conf
#%
#===============================================================================
# BACKUP_END
#===============================================================================
# PRUNE
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} prune
#%
#% DESCRIPTION
#%    Remove unused data, old backups and logs
#%
#% OPTIONS
#%    -a, --all                 Remove all
#%    -b, --backups             Remove old backups
#%    -f. --force               Do not prompt for confirmation
#%    -l, --logs                Remove logs
#%    -r, --backup-retain N     Retain this number of backups.
#%                              (default 30) [BACKUP_RETAIN]
#%    -h, --help                Show this help
#%
#===============================================================================
# PRUNE_END
#===============================================================================
# UPGRADE
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} upgrade
#%
#% DESCRIPTION
#%    Upgrade the user system
#%
#% OPTIONS
#%        --force-config    Override config with default config, without this
#%                          option a forced install will keep a previous config
#%                          intact. This will override the config with the newly
#%                          shipped config. (default false) [FORCE_CONFIG]
#%        --force-profile   Override profile with default profile, without this
#%                          option a forced install will keep a previous profile
#%                          intact. This will override the profile with the newly
#%                          shipped profile. [FORCE_PROFILE]
#%        --local FILE      Install from locally download file. If not provided
#%                          usystem will be downloaded from repository. This
#%                          option will not be presisted to usystem.conf.
#%                          (default USYS_ROOT/usystem.tgz) [USYS_REPO_ARCHIVE]
#%    -h, --help            Show this help
#%
#===============================================================================
# UPGRADE_END
#===============================================================================
# GENERATE
#===============================================================================
#% SYNOPSIS
#+    ${CLI_NAME} generate
#%
#% DESCRIPTION
#%    Generate files from template (*.tmpl) files. This will generates files
#%    with the same name excluding the .tmpl extension. In these generated files
#%    the {...} placeholders will be replaced with their corresponding values.
#%    By default all USYS_ variables will be replaced. To replace a USYS_ value
#%    it must be referenced as a placeholder. Custom place holders van be defined
#%    in the configuration.
#%
#%    By default the absolute value of USYS_ROOT gets replaced with USYS_BIND_DIR.
#%    This results in shorter paths in the generate files.
#%    Use --real-path to turn this off.
#%
#%    rc.d templates will always have the real path embedded because they will be
#%    loaded by the during boot.
#%
#%
#% OPTIONS
#%    -r, --real-path       Use real pahts
#%    -h, --help            Show this help
#%
#% PLACEHOLDERS
#%    {CLI_NAME}
#%    {USYS_BIND_DIR}
#%    {USYS_VOLUME}
#%    {USYS_TARGET}
#%    {USYS_ROOT}
#%    {USYS_BACKUP_DIR}
#%    {USYS_CONFIG_DIR}
#%    {USYS_CONFIG}
#%    {USYS_LOG_DIR}
#%    {USYS_TMP_DIR}
#%
#===============================================================================
# GENERATE_END
#===============================================================================


#===============================================================================
# SHELL CONFIG
#===============================================================================
set -T              # inherit DEBUG and RETURN trap for functions
set -C              # prevent file overwrite by > &> <>
set -E              # inherit -e
set -e              # exit immediately on errors
set -u              # exit on not assigned variables
set -o pipefail     # exit on pipe failure
shopt -s nullglob   # loop 0 times on null glob
shopt -s globstar   # Find files recursivly

# Define script finish function
trap 'finish' EXIT


#===============================================================================
# GLOBAL variables
#===============================================================================
# CLI_NAME
# Name of the CLI command. This can be overriden during install.
# This will allow multiple installations next to each other.
# When set during install, the name will be written as readonly variable to the
# install variable.
declare     CLI_NAME="${CLI_NAME:-usystem}"

# CLI Version
declare -r  CLI_VERSION=1.0.0;
# shellcheck disable=SC2034
declare -r  CLI_DIR="$( cd "$(dirname "$0")" && pwd )";

# Logging
#
# Please note that the log level NONE does not mean 'No Logging'
# NONE is used for output without a log level
declare -rA LOG_LEVELS=([NONE]=0 [DEBUG]=1 [INFO]=2 [WARN]=3 [ERROR]=4);
declare -r  LOG_PFX='%-32s '
declare     LOG_LEVEL="${LOG_LEVEL:-INFO}";

# User system variables
declare     USYS_BIND_DIR="${USYS_BIND_DIR:-/usys}"
declare     USYS_VOLUME="${USYS_VOLUME:-/volume1}";
declare     USYS_TARGET="${USYS_TARGET:-"${USYS_VOLUME}/@${CLI_NAME}"}";
declare     USYS_ROOT="${USYS_ROOT:-"${USYS_TARGET}/${CLI_NAME}"}";
declare     USYS_BACKUP_DIR="${USYS_BACKUP_DIR:-${USYS_TARGET}/backup}";
declare     USYS_CONFIG_DIR="${USYS_CONFIG_DIR:-${USYS_ROOT}/etc}";
declare     USYS_LOG_DIR="${USYS_LOG_DIR:-${USYS_ROOT}/log}";
declare     USYS_TMP_DIR="${USYS_TMP_DIR:-${USYS_ROOT}/tmp}";
declare     USYS_CONFIG="${USYS_CONFIG:-${USYS_CONFIG_DIR}/${CLI_NAME}.conf}"

# User system Repository
declare -r  USYS_REPO_URL="${USYS_REPO_URL:-https://github.com/TimmerTech/synology-usystem}";
declare -r  USYS_REPO_ARCHIVE="${USYS_REPO_ARCHIVE:-${USYS_TARGET}/${CLI_NAME}.tgz}";

# CLI Exec Date/Time
declare -r  CLI_EXEC_DT="$(date +'%Y%m%d-%H%M%S')";

# Install Variables
declare -r  USYS_ENV_VARS="${USYS_CONFIG_DIR}/default/.env"
declare     FORCE=false
declare     FORCE_CONFIG=false
declare     FORCE_PROFILE=false

# Backup variables
declare -r  BACKUP_ARCHIVE="${USYS_BACKUP_DIR}/${CLI_NAME}.backup.${CLI_EXEC_DT}.tgz"

# We will now load the config from the installed location the usystem.conf.
# The configuration will be loaded relative to this script.
# For saftey reasons the variables set during the install phase
# are written to the config as readonly variables.
# This is to ensure that we do not make mistakes. Because during initial install
# the configuration does not exists therefor the variables in the configuration
# marked as readonly are not an issue. This does also provide a secondary benefit.
# When a re-install is preformed, the user can reinstall over the current install
# because the configuration will lock the install variables.
# shellcheck disable=SC2059
if [ -f "${USYS_CONFIG}" ]; then
    # shellcheck disable=SC1090
    source "${USYS_CONFIG}"
fi


#===============================================================================
# FUNCTIONS
#===============================================================================
function scriptinfo_part() {
    local -r PART="${1}"
    local -r FILTER="${2}"

    sed -n "/${PART}/,/${PART}_END/p" "${0}" | grep -e "${FILTER}" | sed -e "s/${FILTER}//g"
}

function scriptinfo_replace_var() {
    local -r VARNAME="${1}"

    sed -e "s|\${${VARNAME}}|${!VARNAME}|g"
}

# scriptinfo
#
# Parameters
#   (1) EXIT Code
#   (2) Command to display info for, defaults to 'help'
#   (3) short/full; display short or full info, defaults to 'full'
function scriptinfo() {
    # Parameters
    local -r EXIT="${1:-0}"
    local -r CMD="${2:-help}"
    local -r DISPLAY="${3:-full}"

    # Filter
    local FILTER="^#[%+]";

    # Configure Display by altering FILTER
    case "${DISPLAY,,}" in
        short ) FILTER="^#+"    ;;
        full  ) FILTER="^#[%+]" ;;
    esac

    case "${CMD,,}" in
        help | usage)
            scriptinfo_part USAGE "${FILTER}" | scriptinfo_replace_var CLI_NAME
        ;;

        version | implementation)
                scriptinfo_part IMPLEMENTATION "${FILTER}" |
                scriptinfo_replace_var CLI_NAME |
                scriptinfo_replace_var CLI_VERSION |
                scriptinfo_replace_var USYS_VOLUME |
                scriptinfo_replace_var USYS_TARGET |
                scriptinfo_replace_var USYS_ROOT |
                scriptinfo_replace_var USYS_BACKUP_DIR |
                scriptinfo_replace_var USYS_CONFIG_DIR |
                scriptinfo_replace_var USYS_LOG_DIR |
                scriptinfo_replace_var USYS_TMP_DIR |
                scriptinfo_replace_var USYS_REPO_URL
        ;;

        *)
            scriptinfo_part "${CMD^^}" "${FILTER}" | scriptinfo_replace_var CLI_NAME
        ;;
    esac

    exit "${EXIT:-0}"
}

function is_root() {
    local -r CMD="${1}"

    if [[ $(/usr/bin/id -u) -ne 0 ]]; then
        printf "'${CLI_NAME} %s' must be run as root\n" "${CMD}"
        exit 1
    fi
}

## Check if enabled
# $1 parameter to Check
#
# usage: if is_enabled "${VAR}"; then
function is_enabled() {
    local -r BOOL="${1}"

    if [ "${BOOL}" = 1 ] || [ "${BOOL}" = true ] || [ "${BOOL,,}" = "true" ] || [ "${BOOL,,}" = "enable" ] || [ "${BOOL,,}" = "enabled" ] || [ "${BOOL,,}" = "on" ]; then
        return 0
    fi

    return 1
}

function remove_from_array() {
    local -n ARR="${1}"
    local -r DELETE="${2}"

    TMP_ARR=()
    for PKG in "${ARRAY[@]}"; do
        for DEL in "${DELETE[@]}"; do
            KEEP=true
            if [[ "${PKG}" == "${DEL}" ]]; then
                KEEP=false
                break
            fi
        done
        if ${KEEP}; then
            TMP_ARR+=("${PKG}")
        fi
    done

    # shellcheck disable=SC2034
    ARR=("${TMP_ARR[@]}")
    unset TMP_ARR
}

function log() {
    local -r LVL="${1}"
    local -r MSG="${2}"

    # Check if log level exists
    [[ ${LOG_LEVELS[${LVL}]} ]] || return 1

    # If log level is NONE; we output the message raw
    if (( ${LOG_LEVELS[${LVL}]} == 0 )) && [ -n "${MSG}" ]; then
        echo "${MSG}"
        return 0
    fi

    # Check is current log level is allowed
    if (( ${LOG_LEVELS[${LVL}]} <= ${LOG_LEVELS[${LOG_LEVEL}]} )); then
        if [ -n "${MSG}" ]; then
            printf '%-5s: %s\n' "${LVL}" "${MSG}"
        fi
    fi
}

function fecho() {
    local -r MSG="${1}"

    # shellcheck disable=SC2059
    printf "${LOG_PFX}" "${MSG}"
}

function fresult() {
    local -r RES="${1}"
    local -r LVL="${2:-NONE}"
    local -r MSG="${3:-""}"

    printf '[%s]\n' "${RES}"
    log "${LVL}" "${MSG}"
}

function log_file() {
    echo "${USYS_LOG_DIR}/${CLI_NAME}.${FUNCNAME[1]}.${CLI_EXEC_DT}.log"
}

# Create directories, not every directory of usystem is stored in the
# repository. Therefor create all required directories.
function create_directories() {
    # Directories
    local -ra DIRECTORIES=(
        etc/bash_completion.d
        etc/certs
        etc/nginx/conf.d
        etc/nginx/sites.enabled
        log
        reports
        sbin
    )

    for DIR in "${DIRECTORIES[@]}"; do
        if [ ! -d "${USYS_ROOT}/${DIR}" ]; then
            mkdir -p "${USYS_ROOT}/${DIR}" || return 1
        fi
    done

    return 0
}

function fix_permissions() {
    local -r LOG="${1}"

    # set permissions on /usys
    chmod -v 755 /usys >> "${LOG}" 2>&1 || return 1
    chown -v root:root /usys >> "${LOG}" 2>&1 || return 1

    local -A PERMISSIONS
    PERMISSIONS[${USYS_ROOT}/bin]="775 root:administrators"
    PERMISSIONS[${USYS_ROOT}/etc]="775 root:administrators"
    PERMISSIONS[${USYS_ROOT}/log]="775 root:administrators"
    PERMISSIONS[${USYS_ROOT}/sbin]="755 root:administrators"

    for P in "${!PERMISSIONS[@]}"; do
        # shellcheck disable=SC2206
        PERM=(${PERMISSIONS[$P]})
        CHMOD=${PERM[0]}
        CHOWN=${PERM[1]}

        chmod -Rv "${CHMOD}" "${P}" >> "${LOG}" 2>&1 || return 1
        chown -Rv "${CHOWN}" "${P}" >> "${LOG}" 2>&1 || return 1
    done

    return 0
}

function generate_vars() {

    # Make sure we start with a clean environment
    rm -f "${USYS_ENV_VARS}"

    # Define install variables
    cat >| "${USYS_ENV_VARS}" <<EOF
declare CLI_NAME=${CLI_NAME}
declare USYS_BIND_DIR=${USYS_BIND_DIR}
declare USYS_VOLUME=${USYS_VOLUME}
declare USYS_TARGET=${USYS_TARGET}
declare USYS_ROOT=${USYS_ROOT}
declare USYS_BACKUP_DIR=${USYS_BACKUP_DIR}
declare USYS_CONFIG_DIR=${USYS_CONFIG_DIR}
declare USYS_CONFIG=${USYS_CONFIG}
declare USYS_LOG_DIR=${USYS_LOG_DIR}
declare USYS_TMP_DIR=${USYS_TMP_DIR}
EOF

}

function replace_placeholders() {
    local SOURCE="${1}"
    local TARGET="${2:-""}"
    local REAL_PATH=${3:-false}

    declare -A USYS_PLACEHOLDERS
    USYS_PLACEHOLDERS[{CLI_NAME}]="${CLI_NAME}"
    USYS_PLACEHOLDERS[{USYS_BIND_DIR}]="${USYS_BIND_DIR}"
    USYS_PLACEHOLDERS[{USYS_BIND_DIR}]="${USYS_BIND_DIR}"
    USYS_PLACEHOLDERS[{USYS_VOLUME}]="${USYS_VOLUME}"
    USYS_PLACEHOLDERS[{USYS_TARGET}]="${USYS_TARGET}"
    USYS_PLACEHOLDERS[{USYS_ROOT}]="${USYS_ROOT}"
    USYS_PLACEHOLDERS[{USYS_BACKUP_DIR}]="${USYS_BACKUP_DIR}"
    USYS_PLACEHOLDERS[{USYS_CONFIG_DIR}]="${USYS_CONFIG_DIR}"
    USYS_PLACEHOLDERS[{USYS_CONFIG}]="${USYS_CONFIG}"
    USYS_PLACEHOLDERS[{USYS_LOG_DIR}]="${USYS_LOG_DIR}"
    USYS_PLACEHOLDERS[{USYS_TMP_DIR}]="${USYS_TMP_DIR}"

    if [ -n "${TARGET}" ]; then
        cp -f "${SOURCE}" "${TARGET}"
        SOURCE="${TARGET}"
    fi

    # Replace {USYS_ENV_VARS}
    # shellcheck disable=SC2016
    sed -i "/{USYS_ENV_VARS}/ {
        r ${USYS_ENV_VARS}
        d
    }" "${SOURCE}"

    for PLACEHOLDER in "${!USYS_PLACEHOLDERS[@]}"; do
        VALUE="${USYS_PLACEHOLDERS[$PLACEHOLDER]}"
        sed -i "s|${PLACEHOLDER}|${VALUE}|g" "${SOURCE}"
    done

    FILENAME="${SOURCE##*/}"
    if ! is_enabled "${REAL_PATH}"; then
        if [[ ! "${FILENAME}" == "rc."* ]] && [[ ! "${SOURCE}" == *"rc.d"* ]] && [[ ! "${FILENAME}" == "${CLI_NAME}.conf" ]]; then
            sed -i "s|${USYS_ROOT}|${USYS_BIND_DIR}|g" "${SOURCE}"
        fi
    fi

}

function install_replace_vars() {
    generate_vars

    for FILE in "${USYS_CONFIG_DIR}/default"/*; do
        # Install Variables in files
        replace_placeholders "${FILE}"
    done

}

function download() {
    local -r LOG=$(log_file)

    # Set umask
    umask 022

    fecho "Downloading usystem ..."
    if wget -L "${USYS_REPO_URL}/archive/main.tar.gz" -O "${USYS_REPO_ARCHIVE}" -o "${LOG}" > /dev/null 2>&1; then
        fresult OK
    else
        fresult FAIL ERROR "Failed to download usystem; see log: ${LOG}"
    fi

    return 0
}

function install_from_archive() {
    local -r LOG="${1}"

    # Set umask
    umask 022

    # Remove USYS_TARGET/install before installing, this directory might be
    # present due to install failure
    if [ -d "${USYS_TARGET}/install" ]; then
        rm -rf "${USYS_TARGET}/install"
    fi

    # Create temporary install directory
    mkdir -p "${USYS_TARGET}/install"

    fecho "Installing ..."
    # Extract archive to USYS_TARGET/install, we are installing to this temporary directory
    # because the user might have choosen to override the default of USYS_ROOT
    # therefor we must create the USYS_ROOT and copy the entire usystem here.
    if tar -xvf "${USYS_REPO_ARCHIVE}" --strip-components=1 -C "${USYS_TARGET}/install" > "${LOG}" 2>&1; then

        # Create USYS_ROOT
        if [ ! -d "${USYS_ROOT}" ]; then
            mkdir -p "${USYS_ROOT}"
        fi

        # Now copy the usystem to the its final destination
        if ! cp -rav "${USYS_TARGET}/install/usystem"/* "${USYS_ROOT}" >> "${LOG}" 2>&1; then
            fresult FAIL ERROR "Failed to move usystem; see log: ${LOG}" && exit 1
        fi

        # Copy LICENSE to USYS_TARGET
        if ! cp -rav "${USYS_TARGET}/install/LICENSE" "${USYS_TARGET}/LICENSE" >> "${LOG}" 2>&1; then
            fresult FAIL ERROR "Failed to move LICENSE; see log: ${LOG}" && exit 1
        fi

        # Remove install folder, to make sure we cleanup after ourselfs
        rm -rf "${USYS_TARGET}/install" >> "${LOG}" 2>&1

        # Install fresult OK
        fresult OK
    else
        fresult FAIL ERROR "failed to install; see log: ${LOG}"
    fi
}

function upgrade_from_archive() {
    # Remove USYS_TARGET/install before installing, this directory might be
    # present due to install failure
    if [ -d "${USYS_TARGET}/install" ]; then
        rm -rf "${USYS_TARGET}/install"
    fi

    # Create temporary install directory
    mkdir -p "${USYS_TARGET}/install"

    fecho "Upgrading ..."
    # Extract archive to USYS_TARGET/install, we are installing to this temporary directory
    # because the user might have choosen to override the default of USYS_ROOT
    # therefor we must create the USYS_ROOT and copy the entire usystem here.
    # The overrides are autoloaded from ${CLI_NAME}.conf when starting the upgrade
    if tar -xvf "${USYS_REPO_ARCHIVE}" --strip-components=1 -C "${USYS_TARGET}/install" > "${LOG}" 2>&1; then
        # Now copy the usystem to the its final destination
        if ! cp -rav "${USYS_TARGET}/install/usystem"/* "${USYS_ROOT}" >> "${LOG}" 2>&1; then
            fresult FAIL ERROR "Failed to move usystem; see log: ${LOG}" && exit 1
        fi

        # Copy LICENSE to USYS_TARGET
        if ! cp -rav "${USYS_TARGET}/install/LICENSE" "${USYS_TARGET}/LICENSE" >> "${LOG}" 2>&1; then
            fresult FAIL ERROR "Failed to move LICENSE; see log: ${LOG}" && exit 1
        fi

        # Remove install folder, to make sure we cleanup after ourselfs
        rm -rf "${USYS_TARGET}/install" >> "${LOG}" 2>&1

        # Install fresult OK
        fresult OK
    else
        fresult FAIL ERROR "Upgrade failed; restoring from backup"
        fecho "Restoring from backup ..."
        if tar -xvf "${BACKUP_ARCHIVE}" -C "${USYSTEM_ROOT_DIR}" > "${LOG}" 2>&1; then
            printf '[OK]\n'

            # Restore complete, removing log
            rm "${REVERT_LOG}"
        else
            fresult FAIL ERROR "Failed to restore backup, manual restore required"
            log ERROR  "See log: ${LOG}"
            exit 1
        fi

        # Terminate upgrade
        exit 1
    fi
}

# install_config
#
# Because we are calling this from the 'install' and 'repair' command
# we want to be able to show the correct message to the user
# therefor this function accepts a MSG as a parameter for this usecase
function install_config() {
    local -r FORCE_CONFIG="${1}"
    local -r MSG="${2}"

    # shellcheck disable=SC1009,SC1072,SC1073
    if [ ! -f "${USYS_CONFIG}" ] || is_enabled "${FORCE_CONFIG}"; then
        fecho "${MSG} config ..."
        if cp "${USYS_CONFIG_DIR}/default/usystem.conf" "${USYS_CONFIG}"; then
            fresult OK
        else
            fresult FAIL ERROR "Failed to install config"
        fi
    fi
}

# install_profile
#
# Because we are calling this from the 'install' and 'repair' command
# we want to be able to show the correct message to the user
# therefor this function accepts a MSG as a parameter for this usecase
function install_profile() {
    local -r FORCE_PROFILE="${1}"
    local -r MSG="${2}"

    # shellcheck disable=SC1009,SC1072,SC1073
    if [ ! -f "${USYS_CONFIG_DIR}/profile" ] || is_enabled "${FORCE_PROFILE}"; then
        fecho "${MSG} profile ..."
        if cp "${USYS_CONFIG_DIR}/default/profile" "${USYS_CONFIG_DIR}/profile"; then
            fresult OK
        else
            fresult FAIL ERROR "Failed to install profile"
        fi
    fi
}

# install_rc
#
# Because we are calling this from the 'install' and 'repair' command
# we want to be able to show the correct message to the user
# therefor this function accepts a MSG as a parameter for this usecase
function install_rc() {
    local -r MSG="${1}"

    fecho "${MSG} rc.usystem ..."
    if cp "${USYS_CONFIG_DIR}/default/rc.${CLI_NAME}" /etc; then
        fresult OK
    else
        fresult FAIL ERROR "Failed to install rc.${CLI_NAME}" && exit 1
    fi

    fecho "${MSG} rc.local ..."
    if cp "${USYS_CONFIG_DIR}/default/rc.local" /etc; then
        fresult OK
    else
        fresult FAIL ERROR "Failed to install rc.local" && exit 1
    fi
}

function get_dsm_version() {
    grep majorversion /etc.defaults/VERSION | cut -d '=' -f 2- | tr -d '"'
}

function servicectl() {
    local -r SRV="${1}"
    local -r CTL="${2}"
    local -r LOG="${3}"
    local -r DSM=$(get_dsm_version)

    case "${DSM}" in
        6)
            if synoservicecfg "--${CTL}" "${SRV}" >> "${LOG}" 2>&1; then
                return 0
            fi
        ;;

        7)
            if systemctl "${CTL}" "${SRV}" >> "${LOG}" 2>&1; then
                return 0
            fi
        ;;
    esac

    return 1
}

# Link nginx
#
# PARAMS
#   LOG file
#
# Return
#  0    Do nothing
#  2    Restart nginx required
function link_nginx() {
    local -r LOG="${1}"
    local RETVAL=0

    for DIR in conf.d sites.enables; do
        for FPATH in "${USYS_CONFIG}/nginx/${DIR}"/*; do
            FILE="$(basename "${FPATH}")"

            # Check if the target file is an actual file
            # if its a real file then we are not going to do anything
            fecho "Link: nginx:${FILE} ..."
            if [ ! -f "/etc/nginx/${DIR}/${FILE}" ] && [ ! -L "/etc/nginx/${DIR}/${FILE}" ]; then
                echo "Linking: $(readlink -f "${FPATH}") => /etc/nginx/${DIR}/${FILE}" >> "${LOG}"
                if ln -sf "$(readlink -f "${FPATH}")" "/etc/nginx/${DIR}/${FILE}" >> "${LOG}" 2>&1; then
                    echo "Verifying Syntax for: /etc/nginx/${DIR}/${FILE}" >> "${LOG}"
                    if nginx -t >> "${LOG}" 2>&1; then
                        fresult OK
                        RETVAL=2
                    else
                        # Syntax of nginx failed
                        # We want to ensure that the nginx is always running because of the DSM UI
                        # therefor we are not allowing invalid Syntax files to persist
                        # because of the syntax error we are now removing our created link
                        echo "Removing link /etc/nginx/${DIR}/${FILE} because of syntax errors" >> "${LOG}"
                        rm -f "/etc/nginx/${DIR}/${FILE}"
                        fresult FAIL ERROR "Syntax Error; see log ${LOG}"
                    fi
                else
                    fresult FAIL ERROR "Failed to create link: see log ${LOG}"
                fi
            else
                echo "/etc/nginx/${DIR}/${FILE} already exists as a file" >> "${LOG}"
                fresult SKIPPED
            fi
        done
    done

    return "${RETVAL}"
}

function prune_backups() {
    local -r FORCE="${1}"
    local -r BACKUPS="${2}"

    RM_PARAMS="-if"
    if is_enabled "${FORCE}"; then
        RM_PARAMS="-f"
    fi
    readonly RM_PARAMS

    fecho "Cleaning backups ..."
    # shellcheck disable=SC2010
    ls -tp "${USYS_BACKUP_DIR}" | grep -v '/$' | tail -n "+$((1 + BACKUPS))" | xargs -I {} rm "${RM_PARAMS}" -- {}
    fresult OK
}

function prune_logs() {
    local -r FORCE="${1}"

    RM_PARAMS="-rif"
    if is_enabled "${FORCE}"; then
        RM_PARAMS="-rf"
    fi
    readonly RM_PARAMS

    fecho "Cleaning logs ..."
    # shellcheck disable=SC2010
    rm "${RM_PARAMS}" "${USYS_LOG_DIR:?}"/*
    fresult OK
}

#===============================================================================
# COMMANDS
#===============================================================================
function install() {
    local -r LOG="${USYS_TARGET}/${CLI_NAME}.${FUNCNAME[1]}.${CLI_EXEC_DT}.log"

    # shellcheck disable=SC2206
    local PARAMS=($@)
    PARAMS+=("--install")
    remove_from_array PARAMS "--force"

    local FORCE="${FORCE:-false}"
    local FORCE_CONFIG="${FORCE_CONFIG:-false}"
    local FORCE_PROFILE="${FORCE_PROFILE:-false}"
    local LOCAL_INSTALL=false

    # Parse options
    while [ ${#} -gt 0 ]; do
        case $1 in
            -h | --help | help)
                scriptinfo 0 install
            ;;

            -f | --force)       FORCE=true;                 readonly FORCE;             shift 1 ;;
            -b,| --bind-dir)    USYS_BIND_DIR="${1}";       readonly USYS_BIND_DIR;     shift 2 ;;
            -v | --volume)      USYS_VOLUME="${1}";         readonly USYS_VOLUME;       shift 2 ;;
            -t | --target-dir)  USYS_TARGET="${1}";         readonly USYS_TARGET;       shift 2 ;;
            -r | --root-dir)    USYS_ROOT="${1}";           readonly USYS_ROOT;         shift 2 ;;

            --cli-name)         CLI_NAME="${1}"             readonly CLI_NAME;          shift 2 ;;
            --backup-dir)       USYS_BACKUP_DIR="${1}";     readonly USYS_BACKUP_DIR;   shift 2 ;;
            --config-dir)       USYS_CONFIG_DIR="${1}";     readonly USYS_CONFIG_DIR;   shift 2 ;;
            --log-dir)          USYS_LOG_DIR="${1}";        readonly USYS_LOG_DIR;      shift 2 ;;
            --force-config)
                FORCE_CONFIG=true; readonly FORCE_CONFIG
                shift 1
            ;;
            --force-profile)
                FORCE_PROFILE=true; readonly FORCE_PROFILE
                shift 1
            ;;
            --local)
                LOCAL_INSTALL=true;         readonly LOCAL_INSTALL;
                USYS_REPO_ARCHIVE="${2}";   readonly USYS_REPO_ARCHIVE
                shift 2
            ;;

            * )
                printf "unknown option: '%s'\n" "${1}"
                scriptinfo 1 install
            ;;
        esac
    done

    # Check if we are running as root
    is_root "${FUNCNAME[0]}"

    # Print header because we also provide online install
    printf '%s\n' "Synology User System"
    printf '%s\n\n' "Version: ${CLI_VERSION}"
    printf '%s\n\n' "For more information visit: https://www.timmertech.io"

    # Verify the volume path exists
    if [ ! -e "${USYS_VOLUME}" ]; then
        log ERROR "Volume: '${USYS_VOLUME}' does not exists"
        exit 1
    fi

    # Create target directory on volume
    if [ ! -d "${USYS_TARGET}" ]; then
        mkdir -p "${USYS_TARGET}"
    fi

    # Create target directory on OS
    if [ ! -d "${USYS_BIND_DIR}" ]; then
        mkdir -p "${USYS_BIND_DIR}"
    fi

    # Verify that the root directory does not exist
    # If it exists, inform the user to use the 'upgrade' command
    # This check can be overridden with '--force'
    # shellcheck disable=SC1009,SC1072,SC1073
    if [ -d "${USYS_ROOT}" ] && ! is_enabled "${FORCE}"; then
        log ERROR "${USYS_ROOT} exist; please use '${CLI_NAME} upgrade'"
        exit 1
    else
        # We are overwriting existing install, create backup
        backup "$@"
    fi

    # Check if we are performing a local install
    # if not then remove possible present downloaded archive
    if ! is_enabled "${LOCAL_INSTALL}"; then
        rm -f "${USYS_REPO_ARCHIVE}"

        # set download log; because we might never be installed, write the
        # download log to USYS_TARGET
        download
    fi

    # Install from archive, either downloaded or local
    install_from_archive "${LOG}"

    # Create directories
    fecho "Creating directories ..."
    if create_directories; then
        fresult OK
    else
        fresult FAIL ERROR: "Failed to create directories" && exit 1
    fi

    # Fix permissions of file/folders
    if ! fix_permissions "${LOG}"; then
        fresult FAIL ERROR "Failed to repair permissions"
    fi

    # Install variables in files, this step is only done during install
    install_replace_vars

    # Call repair user system, to finish the installation
    repair "${PARAMS[@]}"
}

function repair() {
    local -r LOG=$(log_file)
    local FORCE_CONFIG="${FORCE_CONFIG:-false}"
    local FORCE_PROFILE="${FORCE_PROFILE:-false}"
    local CONTEXT_MSG="Repairing"
    local CONTEXT_MSG_FORCE="${CONTEXT_MSG}"

    # Parse options
    while [ ${#} -gt 0 ]; do
        case $1 in
            -h | --help | help)
                scriptinfo 0 repair
            ;;

            # Hidden option, this option only exists for the call from the 'install' command
            # This option exists to correct the message output to the user
            --install)
                CONTEXT_MSG="Installing"; readonly CONTEXT_MSG;
                shift 1
            ;;

            # Hidden option, this option only exists for the call from the 'upgrade' command
            # This option exists to correct the message output to the user
            --upgrade)
                CONTEXT_MSG="Upgrading"; readonly CONTEXT_MSG;
                shift 1
            ;;


            --force-config)
                FORCE_CONFIG=true; readonly FORCE_CONFIG;
                CONTEXT_MSG_FORCE="Override"
                shift 1
            ;;

            --force-profile)
                FORCE_PROFILE=true; readonly FORCE_PROFILE;
                CONTEXT_MSG_FORCE="Override"
                shift 1
            ;;

            * )
                printf "unknown option: '%s'\n" "${1}"
                scriptinfo 1 repair
            ;;
        esac
    done

    # Lock variable CONTEXT_MSG_FORCE
    readonly CONTEXT_MSG_FORCE

    # Check if we are running as root
    is_root "${FUNCNAME[0]}"

    # Fix permissions
    fecho "Repairing permissions ..."
    if fix_permissions "${LOG}"; then
        fresult OK
    else
        fresult FAIL ERROR "Failed to repair permissions" && exit 1
    fi

    # Install config
    install_config "${FORCE_CONFIG}" "${CONTEXT_MSG_FORCE}"

    # Install profile
    install_profile "${FORCE_PROFILE}" "${CONTEXT_MSG_FORCE}"

    # Install run commands
    install_rc "${CONTEXT_MSG}"

    # Start usystem
    # We are going to start the user system from rc.local
    # The reason we are starting from rc.local is that rc.local after it starts
    # starts all user configured rc.d/* because we might be performing a forced
    # install and overwrite an existing installation
    /etc/rc.local

    # Repair completed, now link/re-link all usystem resources back to the OS
    # This will a user to only issue the repair command after a DSM upgrade to
    # completely restore everything
    #
    # Link user system resources to OS
    link "$@"
}

function link() {
    local -r LOG=$(log_file)

    # Parse options
    while [ ${#} -gt 0 ]; do
        case $1 in
            -h | --help | help)
                scriptinfo 0 link
            ;;
            * )
                printf "unknown option: '%s'\n" "${1}"
                scriptinfo 1 link
            ;;
        esac
    done

    # Check if we are running as root
    is_root "${FUNCNAME[0]}"

    # Link nginx
    if [ "$(link_nginx "${LOG}")" = 2 ]; then
        # We have linked syntax error free resources, nginx restart is required
        servicectl nginx restart "${LOG}"
    fi
}

function backup() {
    local -r LOG=$(log_file)
    local BACKUP_RETAIN="${BACKUP_RETAIN:-30}"
    local CLEAN=false
    local FORCE=false

    # Parse options
    while [ ${#} -gt 0 ]; do
        case $1 in
            -h | --help | help)
                scriptinfo 0 backup
            ;;
            -c | --clean)
                CLEAN=true; readonly CLEAN;
                shift 1
            ;;
            -f | --force)
                FORCE=true; readonly FORCE;
                shift 1
            ;;
            -r | --backup-retain)
                BACKUP_RETAIN="${1}"; readonly BACKUP_RETAIN;
                shift 2
            ;;
            * )
                printf "unknown option: '%s'\n" "${1}"
                scriptinfo 1 backup
            ;;
        esac
    done

    # Check if we are running as root
    is_root "${FUNCNAME[0]}"

    umask 022

    # Check if backup directory exists
    if [ ! -d "${USYS_BACKUP_DIR}" ]; then
        mkdir -p "${USYS_BACKUP_DIR}"
    fi

    fecho "Creating backup ..."
    if tar -czf "${BACKUP_ARCHIVE}" --exclude "${CLI_NAME}/tmp" -C "${USYS_TARGET}" "${CLI_NAME}/" > "${LOG}" 2>&1; then
        fresult OK
    else
        fresult FAIL ERROR "Failed to create backup; see log: ${LOG}"
        exit 1
    fi

    # Cleanup backups
    if is_enabled "${CLEAN}"; then
        prune_backups "${FORCE}" "${BACKUP_RETAIN}"
    fi
}

function prune() {
    local -r LOG=$(log_file)
    local BACKUP_RETAIN="${BACKUP_RETAIN:-30}"
    local BACKUPS=false
    local FORCE=false
    local LOGS=false

    # Parse options
    while [ ${#} -gt 0 ]; do
        case $1 in
            -h | --help | help)
                scriptinfo 0 prune
            ;;
            -a | --all)
                BACKUPS=true
                LOGS=true
                shift 1
            ;;
            -b | --backups)
                BACKUPS=true
                shift 1
            ;;
            -f | --force)
                FORCE=true; readonly FORCE;
                shift 1
            ;;
            -l | --logs)
                LOGS=true
                shift 1
            ;;
            -r | --backup-retain)
                BACKUP_RETAIN="${1}"; readonly BACKUP_RETAIN;
                shift 2
            ;;
            * )
                printf "unknown option: '%s'\n" "${1}"
                scriptinfo 1 prune
            ;;
        esac
    done

    # Lock variables here because --all can be given in combination with
    # --backups and --logs
    readonly BACKUPS
    readonly LOGS

    # Clean backups
    if is_enabled "${BACKUPS}"; then
        prune_backups "${FORCE}" "${BACKUP_RETAIN}"
    fi

    # Clean logs
    if is_enabled "${LOGS}"; then
        prune_logs "${FORCE}"
    fi
}

function upgrade() {
    local -r LOG=$(log_file)

    # shellcheck disable=SC2206
    local PARAMS=($@)
    PARAMS+=("--upgrade")
    remove_from_array PARAMS "--local"

    local FORCE_CONFIG="${FORCE_CONFIG:-false}"
    local FORCE_PROFILE="${FORCE_PROFILE:-false}"
    local LOCAL_INSTALL=false

    # Parse options
    while [ ${#} -gt 0 ]; do
        case $1 in
            -h | --help | help)
                scriptinfo 0 upgrade
            ;;
            --force-config)
                FORCE_CONFIG=true; readonly FORCE_CONFIG
                shift 1
            ;;
            --force-profile)
                FORCE_PROFILE=true; readonly FORCE_PROFILE
                shift 1
            ;;
            --local)
                LOCAL_INSTALL=true;         readonly LOCAL_INSTALL;
                USYS_REPO_ARCHIVE="${2}";   readonly USYS_REPO_ARCHIVE
                shift 2
            ;;
            * )
                printf "unknown option: '%s'\n" "${1}"
                scriptinfo 1 upgrade
            ;;
        esac
    done

    # Check if we are running as root
    is_root "${FUNCNAME[0]}"

    # Create backup
    backup "$@"

    # Check if we are performing a local install
    # if not then remove possible present downloaded archive
    if ! is_enabled "${LOCAL_INSTALL}"; then
        rm -f "${USYS_REPO_ARCHIVE}"

        # set download log; because we might never be installed, write the
        # download log to USYS_TARGET
        download
    fi

    # upgrade from archive, either downloaded or local
    upgrade_from_archive "${LOG}"

    # Create directories
    fecho "Creating directories ..."
    if create_directories; then
        fresult OK
    else
        fresult FAIL ERROR: "Failed to create directories" && exit 1
    fi

    # Fix permissions of file/folders
    if ! fix_permissions "${LOG}"; then
        fresult FAIL ERROR "Failed to repair permissions"
    fi

    # Install variables in files, this step is only done during install
    install_replace_vars

    # Call repair user system, to finish the installation
    repair "${PARAMS[@]}"
}

function generate() {
    local REAL_PATH=false

    # Parse options
    while [ ${#} -gt 0 ]; do
        case $1 in
            -h | --help | help)
                scriptinfo 0 generate
            ;;
            -r | --real-path)
                REAL_PATH=true; readonly REAL_PATH
                shift 1
            ;;
            * )
                printf "unknown option: '%s'\n" "${1}"
                scriptinfo 1 generate
            ;;
        esac
    done

    # Check if we are running as root
    is_root "${FUNCNAME[0]}"

    # Generate all files from templates
    for TMPL in "${USYS_ROOT}"/**/*.tmpl; do
        DEST="${TMPL%.*}"
        TMPL_BASE="$(basename "${TMPL}")"
        DEST_BASE="$(basename "${DEST}")"

        log NONE "Generate: ${TMPL_BASE} => ${DEST_BASE}"
        replace_placeholders "${TMPL}" "${DEST}" "${REAL_PATH}"

        # shellcheck disable=SC2153
        for PLACEHOLDER in "${!USER_PLACEHOLDERS[@]}"; do
            VALUE="${USER_PLACEHOLDERS[$PLACEHOLDER]}"
            sed -i "s|${PLACEHOLDER}|${VALUE}|g" "${DEST}"
        done

        if ! is_enabled "${REAL_PATH}"; then
            sed -i "s|${USYS_ROOT}|${USYS_BIND_DIR}|g" "${DEST}"
        fi
    done
}

#===============================================================================
# FINISH
#
# Script cleanup function
# ':' Returns TRUE to ensure empty function is allowed to be defined
#===============================================================================
function finish() {
    # Remove USYS_TARGET/install before installing, this directory might be
    # present due to install failure
    if [ -d "${USYS_TARGET}/install" ]; then
        rm -rf "${USYS_TARGET}/install"
    fi
}


#===============================================================================
# MAIN
#===============================================================================
function main() {
    if (( ${#} == 0 )); then
        scriptinfo 0 usage
    fi

    case ${1} in
        -h | --help | help )
            scriptinfo 0 usage
        ;;

        -v | --version | version )
            scriptinfo 0 version
        ;;

        -l | --log-level )
            LOG_LEVEL="${1^^}"
            shift 1
        ;;

        backup | generate | link | install | prune | repair | upgrade )
            $1 "${@:2}";
        ;;

        * )
            echo "unknown command: $1"
            scriptinfo 1 usage
        ;;
    esac
}

main "$@";
